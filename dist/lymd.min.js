"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var lymd = function (exports) {
  'use strict';
  /**
   * diff AST
   * å¦‚æœnode.typeå‘ç”Ÿå˜åŒ–ï¼Œé‚£å°±æ˜¯replaceï¼Œååˆ™ä¸ºupdate
   * updateéœ€è¦diff propsä¸children
   *  1. propsä¸ºobjectï¼Œä¿ç•™keyä¸ç”¨å‚ä¸diff
   *  2. childrenæ˜¯æ•°ç»„ï¼Œéœ€è¦ä¸€å®šçš„ç®—æ³•
   *
   * diff array
   * 1. å…ˆåˆ é™¤åœ¨nextNodeé‡Œä¸å­˜åœ¨çš„type
   * 2. ä¿ç•™åœ¨nextNodeé‡Œå­˜åœ¨çš„type
   * 3. åˆ é™¤å‰©ä½™çš„å…ƒç´ ï¼Œæœ€åå¾—åˆ° prevKeepArr
   * 4. nextNode ä¸ prevKeepArr æœ€å¯¹æ¯”ï¼Œè¿›è¡Œmove/addæ“ä½œï¼Œ
   *      éœ€è¦æ³¨æ„çš„æ˜¯åœ¨è·å–æ“ä½œçš„è¿‡ç¨‹ï¼Œéœ€è¦ä¸¢prevKeepArrè¿›è¡ŒåŒæ­¥æ›´æ–°
   *      ä¸ç„¶ä¼šå¯¼è‡´æ“ä½œæ··ä¹±ï¼Œæ•°æ®ä¸ä¸€è‡´
   * 5. è¿”å›diffç»“æœ
   */
  // ä¸ºnodeæ·»åŠ id

  /** @typedef {import("./../@type/index").AST} AST */

  function checkIsNoNeedDiff() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    // __ å¼€å¤´çš„æœªå†…éƒ¨ç§æœ‰å±æ€§
    return key.startsWith('__') || ['children', '$getNode', 'type', 'raw', 'tokens', // åŸå§‹tokensä¿¡æ¯
    'push' // nodeèŠ‚ç‚¹ä¸Šçš„pushæ–¹æ³•
    ].includes(key);
  }
  /**
   * diffå¯¹è±¡å·®å¼‚
   * @export
   * @param {AST} [prevNode={}]
   * @param {AST} [nextNode={}]
   * @returns
   */


  function diffObject() {
    var prevNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var nextNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var prevKeys = Object.keys(prevNode);
    var nextKeys = Object.keys(nextNode);
    var change = []; // åˆ é™¤

    prevKeys.forEach(function (key) {
      // ä¸éœ€è¦å‚ä¸diffçš„key
      if (checkIsNoNeedDiff(key)) {
        return;
      }

      if (nextKeys.includes(key)) {
        if (prevNode[key] !== nextNode[key]) {
          change.push({
            type: 'change',
            key: key,
            prevNode: prevNode,
            nextNode: nextNode
          });
        }

        return;
      }

      change.push({
        type: 'del',
        key: key,
        prevNode: prevNode,
        nextNode: nextNode
      });
    });
    nextKeys.forEach(function (key) {
      if (!prevKeys.includes(key)) {
        change.push({
          type: 'add',
          key: key,
          prevNode: prevNode,
          nextNode: nextNode
        });
      }
    });
    return change;
  }
  /**
   * æ·»åŠ node diffï¼Œæå‡æ€§èƒ½
   * @export
   * @param {AST} prevNode
   * @param {AST} nextNode
   * @returns
   **/


  function diffNode(prevNode, nextNode) {
    var diffResultArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var otherInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (prevNode === nextNode) return diffResultArr;

    if (!prevNode) {
      diffResultArr.push(_objectSpread({
        type: 'add',
        prevNode: prevNode,
        nextNode: nextNode
      }, otherInfo));
    } else if (!nextNode) {
      diffResultArr.push(_objectSpread({
        type: 'del',
        prevNode: prevNode,
        nextNode: nextNode
      }, otherInfo));
    } else if (prevNode.type !== nextNode.type) {
      // å¦‚æœç±»å‹ä¸ä¸€æ ·ï¼Œå°±é‡æ–°åˆ›å»º
      diffResultArr.push(_objectSpread({
        type: 'replace',
        prevNode: prevNode,
        nextNode: nextNode
      }, otherInfo));
    } else {
      var _update$propsChange;

      // typeä¸€æ ·ï¼Œæ¯”å¯¹propsä¸children
      var update = {
        type: 'update',
        prevNode: prevNode,
        nextNode: nextNode,
        propsChange: []
      };

      (_update$propsChange = update.propsChange).push.apply(_update$propsChange, _toConsumableArray(diffObject(prevNode, nextNode))); // å¦‚æœå‰åèŠ‚ç‚¹æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œåˆ™ç»§æ‰¿ä¸Šä¸€ä¸ªnodeä¸Šçš„ç›¸å…³ä¿¡æ¯


      nextNode.$getNode = prevNode.$getNode;
      nextNode.__update = prevNode.__update;

      if (update.propsChange.length) {
        diffResultArr.push(update);
      } // å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸Šçš„children æ²¡æœ‰ä»»ä½•æ”¹å˜å¯ä»¥ï¼Œå¿½ç•¥è¿™ä¸ªchildren
      // å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸Šçš„ï¼Œupdateçš„propsä¸ºç©º
      // ç”šè‡³æ¥è®²å¯ä»¥æŠŠtreeæ‹æˆä¸€ç»´æ•°ç»„


      diffArr(prevNode, nextNode, diffResultArr);
    }

    return diffResultArr;
  } // åˆ¤æ–­æ•°ç»„æ˜¯å¦ä¸€è‡´
  // v1ç‰ˆæœ¬ä¸å¯¹æ•°ç»„diffçš„æ€§èƒ½åšä¼˜åŒ–
  // éœ€è¦æ·»åŠ replaceåŠŸèƒ½

  /**
   * prevArr nextArr
   * ä»prevArrä¸­å–å‡ºnextArrä¸­æ‰€å«æœ‰çš„typeï¼Œä¸ºfilterArr
   * ç„¶åå¯¹filterArrä¸­çš„å…ƒç´ è¿›è¡Œmove update add
   * ç„¶ååš patch
   * @export
   * @param {*} prevNode
   * @param {*} nextNode
   * @returns
   */


  function diffArr(prevNode, nextNode) {
    var diffResultArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var _prevNode$children = prevNode.children,
        prevArr = _prevNode$children === void 0 ? [] : _prevNode$children;
    var _nextNode$children = nextNode.children,
        nextArr = _nextNode$children === void 0 ? [] : _nextNode$children; // å¦‚æœä¸å­˜åœ¨è¿™ä¸ªtypeç±»å‹ï¼Œéœ€è¦åˆ é™¤

    var filterPrevArr = prevArr.filter(function (item) {
      if (!nextArr.some(function (i) {
        return i.type === item.type;
      })) {
        diffNode(item, null, diffResultArr);
        return false;
      }

      return true;
    }); // å–æœ‰æ•ˆå…ƒç´ 

    nextArr.forEach(function (item) {
      filterPrevArr.some(function (ele, index) {
        if (ele.type === item.type) {
          filterPrevArr[index] = {
            isDel: true,
            ele: ele
          };
          return true;
        }

        return false;
      });
    }); // åˆ é™¤å‰©ä½™å…ƒç´ 

    filterPrevArr.filter(function (i) {
      return !i.isDel;
    }).forEach(function (item) {
      return diffNode(item, null, diffResultArr);
    }); // å–å‡ºæœ‰ç”¨çš„å…ƒç´ 

    var ff = filterPrevArr.filter(function (i) {
      return i.isDel;
    }).map(function (i) {
      return i.ele;
    }); // æœ€åçš„move/update add

    nextArr.forEach(function (item, moveTo) {
      var isMatch = ff.some(function (ele, index) {
        if (ele.type === item.type) {
          // æ³¨é‡Šå…ƒç´ ï¼Œè¡¨ç¤ºå…¶å·²ç»ä½¿ç”¨è¿‡äº†
          ff.splice(index, 1); // éœ€è¦æŠŠffçš„å…ƒç´ ä½ç½®è¿›è¡Œå®æ—¶æ›´æ–°ï¼Œå¦åˆ™å°†ä¼šå‡ºç°ä½ç½®é”™ä¹±

          ff.splice(moveTo > index ? moveTo - 1 : moveTo, 0, {
            used: true,
            ele: ele
          });

          if (index !== moveTo) {
            diffResultArr.push({
              type: 'move',
              prevNode: ele,
              nextNode: item,
              current: index,
              // å¦‚æœç›®æ ‡ä½ç½®å¤§äºå½“å‰ä½ç½®ï¼Œåˆ™éœ€è¦ç§»åŠ¨çš„ç›®æ ‡å…ƒç´ ä¸‹ä¸€ä¸ªå…ƒç´ çš„å‰é¢
              moveTo: moveTo > index ? moveTo + 1 : moveTo
            });
          } // å…ƒç´ éœ€è¦å…ˆç§»åŠ¨


          diffNode(ele, item, diffResultArr);
          return true;
        }

        return false;
      });

      if (!isMatch) {
        // ä½¿ç”¨å ç”¨å…ƒç´ ï¼Œä»¥çŸ«æ­£index
        ff.splice(moveTo, 0, {
          add: true,
          item: item
        });
        diffNode(null, item, diffResultArr, {
          moveTo: moveTo
        });
      }
    }); // é¦–å…ˆæ¥è®²filterPrevArrçš„æ‰€æœ‰type, nextArrå†…éƒ½æ˜¯å­˜åœ¨çš„ï¼Œä½†å¯èƒ½æ•°é‡æ˜¯ä¸ä¸€è‡´çš„
    // [ 1 2 3 ] [ 1 4 3 5 2 ]
    // 4 åœ¨ [ 2 3 ] ä¸­ä¸å­˜åœ¨ï¼Œinsert after 1
    // 3 åœ¨ [ 2 3 ] ä¸­å­˜åœ¨ï¼Œä½†æ˜¯3å‰é¢è¿˜æœ‰2ï¼Œå› æ­¤éœ€è¦moveï¼Œmoveåˆ°4åé¢
    // 5 åœ¨ [ 2 ] ä¸­ä¸å­˜åœ¨, insert after 3
    // 2 æ—© [ 2 ] ä¸­å­˜åœ¨ï¼Œä¿æŒä¸å˜
  }

  var nodeType = {
    text: 'text',
    url: 'a',
    img: 'img',
    video: 'video',
    audio: 'audio',
    inlineCode: 'inlineCode',
    br: 'br',
    hr: 'hr',
    root: 'root',
    blod: 'b',
    italic: 'i',
    linethrough: 'lineThrough',
    // æ ‡é¢˜
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    queto: 'queto',
    code: 'code',
    table: 'table',
    thead: 'thead',
    tbody: 'tbody',
    tr: 'tr',
    th: 'th',
    td: 'td',
    ul: 'ul',
    li: 'li',
    li_done: 'li-done',
    li_todo: 'li-todo'
  };
  var TOKEN_TYPE = {
    NO_ORDER_LIST: 'no_order_list',
    // -
    ORDER_LIST: 'order_list',
    // +
    SIMPLE_URL_START: 'simple_url_start',
    // <
    SIMPLE_URL_END: 'simple_url_end',
    // >
    URL_START: 'url_start',
    // [
    URL_END: 'url_end',
    // ]
    URL_DESC_START: 'url_desc_start',
    // (
    URL_DESC_END: 'url_desc_end',
    // )
    HEAD_TITLE: 'head_title',
    // #
    IMG_START: 'img_start',
    // !
    TABLE_SPLIT: 'table_split',
    // |
    CODE_BLOCK: 'code_block',
    // `
    WHITE_SPACE: 'white_space',
    //
    LINE_END: 'line_end',
    // \n
    LINE_THROUGH: 'linethrough',
    // ~
    BLOB: 'blob',
    // *
    STRING: 'string' // éä»¥ä¸Šå…³é”®å­—ç¬¦ä¹‹å¤–çš„è¿ç»­å­—ç¬¦

  }; // @ts-check
  // TODO:
  // é€’å½’è¿­ä»£
  // æ”¯æŒå¤šå­—ç¬¦ä¸²åŒ¹é…ï¼Œæ”¯æŒå‘å‰çœ‹ï¼Œå‘åçœ‹
  // æ€§èƒ½ä¼˜åŒ–ï¼Œåœ¨è§£æcontentçš„æ—¶å€™ï¼Œé¡ºå¸¦è§£æèŠ‚ç‚¹ä¿¡æ¯ï¼Œé¿å…ç®—æ³•å¤æ‚åº¦æå‡ğŸ¤”
  // å¦‚æœå½“å‰èŠ‚ç‚¹ä¿¡æ¯ç±»å‹ä¸ç¡®è®¤ï¼Œæ˜¯å¦å­˜å½±å“å…¶åç»­tokençš„è§£æè§„åˆ™å‘¢ï¼Ÿ

  var Token = function Token(type, raw, start, end) {
    _classCallCheck(this, Token);

    this.type = type;
    this.start = start;
    this.end = end;
    this.raw = raw;
  };

  var ASTNode = /*#__PURE__*/function () {
    function ASTNode() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      _classCallCheck(this, ASTNode);

      this.type = type;
      this.tokens = tokens;
      this.children = [];
      this.value = '';
    }
    /**
     * @param {ASTNode} child
     * @returns
     * @memberof ASTNode
     */


    _createClass(ASTNode, [{
      key: "push",
      value: function push(child) {
        child.__parent = this;
        this.children.push(child);
        return this;
      } // å¯ä»¥æŠŠè¿ç»­çš„text tokenåˆå¹¶æˆä¸€ä¸ªText Node

    }, {
      key: "addToken",
      value: function addToken(token) {
        token && this.tokens.push(token); // ä»…å¯¹äºtext nodeæ‰æœ‰valueå±æ€§

        this.value = this.tokens.map(function (i) {
          return i.raw;
        }).join('');
      }
    }, {
      key: "raw",
      get: function get() {
        return this.children.map(function (i) {
          return i.tokens.map(function (i) {
            return i.raw;
          }).join('');
        }).join('') || this.tokens.map(function (i) {
          return i.raw;
        }).join('');
      }
    }]);

    return ASTNode;
  }();

  function createAstNode(type) {
    var tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var ast = new ASTNode(type, tokens);
    Object.assign(ast, properties);

    if (type === nodeType.text) {
      ast.addToken();
    }

    return ast;
  }

  function token() {
    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    /** @type {Token[]} */
    var tokens = [];
    var index = 0;

    while (index < input.length) {
      var char = input[index];
      var offset = 1;

      switch (char) {
        case '-':
          {
            tokens.push(new Token(TOKEN_TYPE.NO_ORDER_LIST, char, index, index + 1));
            break;
          }

        case '+':
          {
            tokens.push(new Token(TOKEN_TYPE.ORDER_LIST, char, index, index + 1));
            break;
          }

        case '<':
          {
            tokens.push(new Token(TOKEN_TYPE.SIMPLE_URL_START, char, index, index + 1));
            break;
          }

        case '>':
          {
            tokens.push(new Token(TOKEN_TYPE.SIMPLE_URL_END, char, index, index + 1));
            break;
          }

        case '(':
          {
            tokens.push(new Token(TOKEN_TYPE.URL_START, char, index, index + 1));
            break;
          }

        case ')':
          {
            tokens.push(new Token(TOKEN_TYPE.URL_END, char, index, index + 1));
            break;
          }

        case '[':
          {
            tokens.push(new Token(TOKEN_TYPE.URL_DESC_START, char, index, index + 1));
            break;
          }

        case ']':
          {
            tokens.push(new Token(TOKEN_TYPE.URL_DESC_END, char, index, index + 1));
            break;
          }

        case '#':
          {
            tokens.push(new Token(TOKEN_TYPE.HEAD_TITLE, char, index, index + 1));
            break;
          }

        case '!':
          {
            tokens.push(new Token(TOKEN_TYPE.IMG_START, char, index, index + 1));
            break;
          }

        case '|':
          {
            tokens.push(new Token(TOKEN_TYPE.TABLE_SPLIT, char, index, index + 1));
            break;
          }

        case '`':
          {
            tokens.push(new Token(TOKEN_TYPE.CODE_BLOCK, char, index, index + 1));
            break;
          }

        case '~':
          {
            tokens.push(new Token(TOKEN_TYPE.LINE_THROUGH, char, index, index + 1));
            break;
          }

        case '*':
          {
            tokens.push(new Token(TOKEN_TYPE.BLOB, char, index, index + 1));
            break;
          }

        case ' ':
          {
            var lastToken = tokens[tokens.length - 1];

            if (lastToken && lastToken.type === TOKEN_TYPE.WHITE_SPACE) {
              lastToken.raw += char;
              lastToken.end += 1;
            } else {
              tokens.push(new Token(TOKEN_TYPE.WHITE_SPACE, char, index, index + 1));
            }

            break;
          }

        case '\n':
          {
            tokens.push(new Token(TOKEN_TYPE.LINE_END, char, index, index + 1));
            break;
          }

        default:
          {
            // å‘åçœ‹ä¸€ä½
            var nextChar = input[index + 1];
            var str = ''; // å¤„ç†è½¬è¯‘å­—ç¬¦\ï¼Œé¿å…å…³é”®charä¸èƒ½å¤Ÿæ­£å¸¸æ˜¾ç¤º

            var _ref = char === '\\' && nextChar ? [nextChar, 2] : [char, 1];

            var _ref2 = _slicedToArray(_ref, 2);

            str = _ref2[0];
            offset = _ref2[1];
            var _lastToken = tokens[tokens.length - 1];

            if (_lastToken && _lastToken.type === TOKEN_TYPE.STRING) {
              _lastToken.raw += str;
              _lastToken.end += offset;
            } else {
              tokens.push(new Token(TOKEN_TYPE.STRING, str, index, index + offset));
            }
          }
      }

      index += offset;
    }

    return tokens;
  }
  /**
   * å‘åçœ‹ï¼ŒçŸ¥é“æ»¡è¶³æŸä¸€ä¸ªæ¡ä»¶
   * @param {number} index
   * @param {Token[]} tokens
   * @param {(t: Token, offset: number, move: Function) => bool} fn
   * @returns
   */


  function watchAfterUtil(index, tokens, fn) {
    var matchTokens = [];
    var offset = index;

    var moveIndex = function moveIndex(offsetNum) {
      offset += offsetNum;
      return [tokens[offset], offset];
    };

    while (offset < tokens.length) {
      var item = tokens[offset]; // å¦‚æœåŒ¹é…æˆåŠŸï¼Œä¼šå‘ååŠ +1

      if (!fn(item, offset, moveIndex)) {
        break;
      } else {
        matchTokens.push(item);
      }

      offset += 1;
    }

    return {
      matchTokens: matchTokens,
      nextToken: tokens[offset]
    };
  }
  /**
   * å‘åçœ‹å‡ ä¸ªtokenï¼Œä»¥åˆ¤æ–­æ˜¯å¦ç¬¦åˆé¢„æœŸ
   * @param {Token[]} tokens
   * @param {number} offset å½“å‰index
   * @param {number} [length=1] éœ€è¦åç»­å‡ ä¸ªtoken
   * @returns
   */


  function watchAfter(tokens, offset) {
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    // ä½¿ç”¨forå¾ªç¯æ›¿ä»£sliceï¼Œå› ä¸ºsliceä¸ä¼šä¸¥æ ¼è¿”å›æŒ‡å®šé•¿åº¦çš„æ•°ç»„
    var sliceTK = [];

    for (var index = offset + 1; index < offset + length + 1; index++) {
      sliceTK.push(tokens[index]);
    }

    return sliceTK;
  }

  var helper = {
    // åˆ¤æ–­å½“å‰tokenæ˜¯ä¸æ˜¯è¡Œå°¾ï¼Œæˆ–è€…æ–‡æœ¬ç»“æŸ
    isLineEnd: function isLineEnd(token) {
      return !token || token.type === TOKEN_TYPE.LINE_END;
    },
    checkIsEnd: function checkIsEnd(tokens, index) {
      var _ref3 = [tokens[index], tokens[index + 1]],
          currentToken = _ref3[0],
          nextToken = _ref3[1];

      if (!currentToken) {
        return {
          match: []
        };
      } else if (currentToken.type === TOKEN_TYPE.LINE_END) {
        return {
          match: [currentToken]
        };
      }

      if (!nextToken) {
        return {
          match: [currentToken]
        };
      }

      return {};
    },
    // åˆ¤æ–­ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯è¡Œå°¾
    nextIsLienEnd: function nextIsLienEnd(tokens, index) {
      var token = tokens[index + 1];
      return token && token.type === TOKEN_TYPE.LINE_END;
    },
    // åˆ¤æ–­indexçš„å‰ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯è¡Œé¦–
    isLineStart: function isLineStart(tokens, index) {
      var token = tokens[index - 1];
      return !token || token.type === TOKEN_TYPE.LINE_END;
    },
    isType: function isType(token) {
      for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        types[_key - 1] = arguments[_key];
      }

      if (typeof token === 'string') {
        return types.includes(token);
      }

      return token && types.includes(token.type);
    },
    // ç»§ç»­å‘ååŒ¹é…è¡¨ç¤º
    goOn: {
      matchEnd: false
    },
    // åˆ¤æ–­æ˜¯å¦å¯ä»¥ç»§ç»­å‘ååŒ¹é…
    isCanGoOn: function isCanGoOn(r) {
      return this.goOn === r;
    },
    // tokensè½¬å­—ç¬¦ä¸²
    tokensToString: function tokensToString(tokens) {
      return tokens.map(function (i) {
        return i.raw;
      }).join('');
    },
    getQueueContent: function getQueueContent() {
      var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var info = {};
      queue.forEach(function (i) {
        if (i.content) {
          info[i.name] = i.content;
          info[i.name + '_raw'] = i;
        }
      });
      return info;
    },
    getIdentMatcher: function getIdentMatcher() {
      return {
        content: [],
        name: 'ident',
        test: function test(type) {
          if (type !== TOKEN_TYPE.WHITE_SPACE) {
            return {
              offset: 0
            };
          }

          return helper.goOn;
        }
      };
    }
  };
  /**
   * è§£æè¡Œå†…å…ƒç´ 
   * @param {number} index
   * @param {Token[]} tokens
   * @param {ASTNode} parentNode
   * @returns
   */

  function toInlineNode(index, tokens, parentNode) {
    var token = tokens[index];

    if (parseImg(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.img, matchTokens);
      node.src = helper.tokensToString(info.src);
      node.alt = helper.tokensToString(info.alt);
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseUrl(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.url, matchTokens, {
        href: helper.tokensToString(info.src)
      });
      node.push(createAstNode(nodeType.text, info.alt));
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseInlineCode(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.inlineCode, matchTokens);
      node.push(createAstNode(nodeType.text, info.code));
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseSimpleUrl(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.url, matchTokens, {
        href: helper.tokensToString(info.src)
      });
      node.push(createAstNode(nodeType.text, info.src));
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseLineThrough(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.linethrough, matchTokens);
      parseInlineNodeLoop(info.content, node);
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseBlob(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.blod, matchTokens);
      parseInlineNodeLoop(info.content, node);
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    if (parseItalic(index, tokens, function (matchTokens, info) {
      var node = createAstNode(nodeType.italic, matchTokens);
      parseInlineNodeLoop(info.content, node);
      parentNode.push(node);
      index += matchTokens.length;
    })) {
      return index;
    }

    var lastMnode = parentNode.children[parentNode.children.length - 1];

    if (lastMnode && lastMnode.type === nodeType.text) {
      lastMnode.addToken(token);
    } else {
      parentNode.push(createAstNode(nodeType.text, [token]));
    }

    index += 1;
    return index;
  }
  /**
   * è§£æè¡Œå†…èŠ‚ç‚¹
   * @param {Token[]} tokens
   * @param {ASTNode} parentNode
   */


  function parseInlineNodeLoop(tokens, parentNode) {
    var index = 0;

    while (index < tokens.length) {
      index = toInlineNode(index, tokens, parentNode);
    }
  }
  /**
   * å¦‚æœæƒ³é€’å½’åˆ†æï¼Œé‚£å°±éœ€è¦æŠŠstart/endæºå¸¦ä¸Šï¼Œè¿™æ ·å°±ä¸ç”¨ä¸åœçš„åˆ†é…æ–°æ•°ç»„äº†
   * æŠŠtokenè½¬æ¢ä¸ºNode
   * @param {Token[]} tokens
   */


  function toAST(tokens, defaultRoot) {
    var root = defaultRoot || createAstNode(nodeType.root, tokens);
    var index = 0;

    while (index < tokens.length) {
      var _token = tokens[index];

      if (!_token) {
        break;
      } // æ˜¯ä¸æ˜¯è¡Œé¦–
      // parse head


      if (_token.type === TOKEN_TYPE.LINE_END) {
        root.push(createAstNode(nodeType.br, [_token]));
        index += 1;
        continue;
      }

      if (parseHead(index, tokens, function (matchTokens, info) {
        var node = createAstNode(nodeType['h' + info.headLevel.length], matchTokens);
        parseInlineNodeLoop(info.children, node);
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      if (parseBlockCode(index, tokens, function (matchTokens, info) {
        var node = createAstNode(nodeType.code, matchTokens, {
          code: helper.tokensToString(info.code),
          language: helper.tokensToString(info.language).trim()
        });
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      if (parseBlockQuote(index, tokens, function (matchTokens, info) {
        var node = createAstNode(nodeType.queto, matchTokens);
        toAST(info.children, node);
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      if (parseTable(index, tokens, function (matchTokens, info) {
        var node = createAstNode(nodeType.table, matchTokens);
        var thead = createAstNode(nodeType.thead, info.thead);
        var theadTr = createAstNode(nodeType.tr, info.thead);
        thead.push(theadTr);
        info.thead_raw.children.forEach(function (item) {
          var th = createAstNode(nodeType.th, item);
          parseInlineNodeLoop(item, th);
          theadTr.push(th);
        });
        node.push(thead);
        var tbody = createAstNode(nodeType.tbody, info.tbody);
        info.tbody_raw.children.forEach(function (item) {
          var tbodyTr = createAstNode(nodeType.tr, info.tbody);
          tbody.push(tbodyTr);
          info.thead_raw.children.forEach(function (_, index) {
            var ele = item[index] || [];
            var td = createAstNode(nodeType.td, ele);
            parseInlineNodeLoop(ele, td);
            tbodyTr.push(td);
          }); // item.forEach(ele => {
          //     const td = createAstNode(nodeType.td, item)
          //     parseInlineNodeLoop(ele, td)
          //     tbodyTr.push(td)
          // })
        });
        node.push(tbody);
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      if (parseHr(index, tokens, function (matchTokens) {
        var node = createAstNode(nodeType.hr, matchTokens);
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      if (parseList(index, tokens, function (matchTokens, info) {
        var node = createAstNode(nodeType.ul, matchTokens);
        node.listStyleType = info[0].listStyleType;
        info.forEach(function (item) {
          var liNode = createAstNode(item.nodeType || nodeType.li);
          parseInlineNodeLoop(item.head, liNode);
          item.children.forEach(function (ele) {
            parseInlineNodeLoop(ele.content, liNode);
          });
          node.push(liNode);
        });
        root.push(node);
        index += matchTokens.length;
      })) {
        continue;
      }

      index = toInlineNode(index, tokens, root);
    }

    return root;
  }
  /** @typedef {(matchTokens: Token[], info: Object) => any } MatchHanlder  */

  /**
   * åŒ¹é…
   * @param {number} index
   * @param {Array} tokens
   * @param {Array} queue
   * @param {MatchHanlder} handler
   * @returns {boolean}
   */


  function matchUsefulTokens(index, tokens, queue, handler) {
    var matchTokens = [];
    var queueTypeIndex = 0;
    watchAfterUtil(index, tokens, function (item, currentIndex, moveIndex) {
      while (true) {
        if (_typeof(queue[queueTypeIndex]) === 'object') {
          // offsetçš„åç§» + indexå¤§äºtokensé•¿åº¦æ—¶ï¼Œitemä¸å­˜åœ¨äº†
          if (!item) {
            break;
          }

          var testResult = queue[queueTypeIndex].test(item.type, currentIndex, tokens);

          if (helper.isCanGoOn(testResult)) {
            queue[queueTypeIndex].content.push(item);
            matchTokens.push(item);
            return true;
          } // ç»ˆæ­¢å‘ä¸‹è§£æ


          if (!testResult || queue[queueTypeIndex].stop) {
            return false;
          } // ç§»åŠ¨index


          if (testResult.offset > 0) {
            matchTokens.push.apply(matchTokens, _toConsumableArray(tokens.slice(currentIndex, currentIndex + testResult.offset))); // æ ¹æ®offsetå»çŸ«æ­£åç§»é‡

            var _moveIndex = moveIndex(testResult.offset);

            var _moveIndex2 = _slicedToArray(_moveIndex, 2);

            item = _moveIndex2[0];
            currentIndex = _moveIndex2[1];
          } // TODO: å½“offsetå¤§äº0çš„æ—¶å€™éœ€è¦è®°å½•æŒ‡å®šçš„èŠ‚ç‚¹æ¯”å¦‚ ç»“æŸæ ‡ç­¾```


          queueTypeIndex += 1; // ç»§ç»­ä»å¤´å¾ªç¯

          continue;
        } // è¿™é‡Œåœ¨å‡è®¾ä¸‹ä¸€ä¸ªtypeä¸€å®šä¸æ˜¯ä¸€ä¸ªObject


        if (queue[queueTypeIndex] && item.type === queue[queueTypeIndex]) {
          queueTypeIndex += 1;
          matchTokens.push(item); // ç›´åˆ°æ‰€æœ‰çš„éƒ½åŒ¹é…åˆ°

          return queueTypeIndex !== queue.length;
        }

        return false;
      }
    }); // æ²¡æœ‰åœæ­¢è§£æçš„

    if (queueTypeIndex === queue.length && queue.every(function (i) {
      return !i.stop;
    })) {
      handler(matchTokens, helper.getQueueContent(queue));
      return true;
    }

    return false;
  }
  /**
   * è§£æå›¾ç‰‡
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseImg(index, tokens, handler) {
    if (!helper.isType(tokens[index], TOKEN_TYPE.IMG_START)) {
      return false;
    }

    var matchTokens = [tokens[index]];

    if (parseUrl(index + 1, tokens, function (urlMatchTokens, info) {
      handler(matchTokens.concat(urlMatchTokens), info);
    })) {
      return true;
    }

    return false;
  }
  /**
   * è§£æurl
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseUrl(index, tokens, handler) {
    // å¦‚ä½•å®Œç¾ç»“åˆèµ·æ¥
    var queue = [TOKEN_TYPE.URL_DESC_START, {
      content: [],
      name: 'alt',
      test: function test(type) {
        return helper.isType(type, TOKEN_TYPE.URL_DESC_START, TOKEN_TYPE.URL_DESC_END) ? {
          offset: 0
        } : helper.goOn;
      }
    }, TOKEN_TYPE.URL_DESC_END, TOKEN_TYPE.URL_START, {
      content: [],
      name: 'src',
      test: function test(type) {
        return helper.isType(type, TOKEN_TYPE.URL_START, TOKEN_TYPE.URL_END) ? {
          offset: 0
        } : helper.goOn;
      }
    }, TOKEN_TYPE.URL_END]; // åœ¨è¿™é‡Œå­˜å‚¨åŒ¹é…åˆ°çš„ç»“æœï¼Œç„¶åå¯¹ï¼ŒæŸäº›å¯é€’å½’å…ƒç´ ç»§ç»­è§£æ æ¯”å¦‚ [can parse content]()

    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æç®€å•url <xxxxx>
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseSimpleUrl(index, tokens, handler) {
    var queue = [TOKEN_TYPE.SIMPLE_URL_START, {
      content: [],
      name: 'src',
      test: function test(type) {
        if (helper.isType(type, TOKEN_TYPE.SIMPLE_URL_START, TOKEN_TYPE.SIMPLE_URL_END, TOKEN_TYPE.LINE_END, TOKEN_TYPE.WHITE_SPACE)) {
          return {
            offset: 0
          };
        }

        return helper.goOn;
      }
    }, TOKEN_TYPE.SIMPLE_URL_END];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æè¡Œå†…code
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseInlineCode(index, tokens, handler) {
    // ä¸èƒ½æ˜¯è¿ç»­çš„``
    if (helper.isType(tokens[index], TOKEN_TYPE.CODE_BLOCK) && helper.isType(tokens[index + 1], TOKEN_TYPE.CODE_BLOCK)) {
      return false;
    }

    var queue = [TOKEN_TYPE.CODE_BLOCK, {
      content: [],
      name: 'code',
      repeatable: true,
      ignore: true,
      test: function test(type) {
        if (helper.isType(type, TOKEN_TYPE.CODE_BLOCK)) {
          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£ææ–‡æœ¬ä¸­åˆ’çº¿
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseLineThrough(index, tokens, handler) {
    var queue = [TOKEN_TYPE.LINE_THROUGH, TOKEN_TYPE.LINE_THROUGH, {
      content: [],
      name: 'content',
      test: function test(type, index, tokens) {
        if ([tokens[index + 1], tokens[index + 2]].every(function (i) {
          return helper.isType(i, TOKEN_TYPE.LINE_THROUGH);
        })) {
          this.content.push(tokens[index]);
          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }, TOKEN_TYPE.LINE_THROUGH, TOKEN_TYPE.LINE_THROUGH];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æå€¾æ–œ
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseItalic(index, tokens, handler) {
    var queue = [TOKEN_TYPE.BLOB, {
      content: [],
      name: 'content',
      test: function test(type, index, tokens) {
        if ([tokens[index + 1]].every(function (i) {
          return helper.isType(i, TOKEN_TYPE.BLOB);
        })) {
          this.content.push(tokens[index]);
          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }, TOKEN_TYPE.BLOB];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æåŠ ç²—
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseBlob(index, tokens, handler) {
    var queue = [TOKEN_TYPE.BLOB, TOKEN_TYPE.BLOB, {
      content: [],
      name: 'content',
      test: function test(type, index, tokens) {
        if ([tokens[index + 1], tokens[index + 2]].every(function (i) {
          return helper.isType(i, TOKEN_TYPE.BLOB);
        })) {
          this.content.push(tokens[index]);
          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }, TOKEN_TYPE.BLOB, TOKEN_TYPE.BLOB];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£ææ ‡é¢˜
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseHead(index, tokens, handler) {
    if (!helper.isLineStart(tokens, index)) {
      return false;
    } // å®ç°ä¸€ä¸ªç®€å•çš„å‘å‰å‘åçœ‹çš„æ­£åˆ™


    var queue = [helper.getIdentMatcher(), {
      content: [],
      name: 'headLevel',
      stop: false,
      test: function test(type, index, tokens) {
        var _watchAfterUtil = watchAfterUtil(index, tokens, function (item) {
          return helper.isType(item, TOKEN_TYPE.HEAD_TITLE);
        }),
            matchTokens = _watchAfterUtil.matchTokens;

        if (matchTokens.length > 6 || matchTokens.length === 0) {
          this.stop = true;
          return false;
        }

        this.content = matchTokens; // é€šè¿‡å‘å‰çœ‹ï¼Œå‘åçœ‹ä»¥è§£æåˆ¤æ–­ï¼Œæ˜¯å¦å‘½ä¸­NodeèŠ‚ç‚¹

        return {
          offset: matchTokens.length
        };
      }
    }, {
      content: [],
      name: 'children',
      repeatable: true,
      ignore: true,
      test: function test(type, index, tokens) {
        // é€šè¿‡å‘å‰çœ‹ï¼Œå‘åçœ‹ä»¥è§£æåˆ¤æ–­ï¼Œæ˜¯å¦å‘½ä¸­NodeèŠ‚ç‚¹
        if (helper.isLineEnd(tokens[index])) {
          return {
            offset: 1
          }; // å¿½ç•¥å°¾éƒ¨\n
        }

        return helper.goOn;
      }
    }];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æä»£ç å—
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseBlockCode(index, tokens, handler) {
    if (!helper.isLineStart(tokens, index)) {
      return false;
    } // å®ç°ä¸€ä¸ªç®€å•çš„å‘å‰å‘åçœ‹çš„æ­£åˆ™


    var queue = [TOKEN_TYPE.CODE_BLOCK, TOKEN_TYPE.CODE_BLOCK, TOKEN_TYPE.CODE_BLOCK, {
      content: [],
      name: 'language',
      test: function test(type, index, tokens) {
        // ä¿ç•™æ¢è¡Œç¬¦
        if (helper.isLineEnd(tokens[index])) {
          this.content.push(tokens[index]);
          return {
            offset: 1
          };
        } else if (helper.nextIsLienEnd(tokens, index)) {
          this.content.push(tokens[index], tokens[index + 1]); // debugger

          return {
            offset: 2
          };
        }

        return helper.goOn;
      }
    }, {
      content: [],
      name: 'code',
      test: function test(type, index, tokens) {
        // é€šè¿‡å‘å‰çœ‹ï¼Œå‘åçœ‹ä»¥è§£æåˆ¤æ–­ï¼Œæ˜¯å¦å‘½ä¸­NodeèŠ‚ç‚¹
        if (type === TOKEN_TYPE.CODE_BLOCK) {
          return helper.isLineStart(tokens, index) && watchAfter(tokens, index, 3).every(function (item, at) {
            if (at === 2) {
              return helper.isLineEnd(item);
            }

            return helper.isType(item, TOKEN_TYPE.CODE_BLOCK);
          }) ? {
            offset: 3
          } : helper.goOn;
        }

        return helper.goOn;
      }
    }];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æåˆ†å‰²çº¿
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseHr(index, tokens, handler) {
    // å®ç°ä¸€ä¸ªç®€å•çš„å‘å‰å‘åçœ‹çš„æ­£åˆ™
    var queue = [{
      content: [],
      name: 'hr',
      test: function test(type, index, tokens) {
        // é€šè¿‡å‘å‰çœ‹ï¼Œå‘åçœ‹ä»¥è§£æåˆ¤æ–­ï¼Œæ˜¯å¦å‘½ä¸­NodeèŠ‚ç‚¹
        if (helper.isType(tokens[index], TOKEN_TYPE.NO_ORDER_LIST)) {
          var isMatch = helper.isLineStart(tokens, index) && watchAfter(tokens, index, 3).every(function (item, at) {
            if (at === 2) {
              return helper.isLineEnd(item);
            }

            return helper.isType(item, TOKEN_TYPE.NO_ORDER_LIST);
          });
          return isMatch ? {
            offset: 3
          } : false;
        }

        return false;
      }
    }];
    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æå—çº§å¼•ç”¨
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseBlockQuote(index, tokens, handler) {
    if (!helper.isLineStart(tokens, index)) {
      return false;
    } // å®ç°ä¸€ä¸ªç®€å•çš„å‘å‰å‘åçœ‹çš„æ­£åˆ™


    var queue = [TOKEN_TYPE.SIMPLE_URL_END, {
      content: [],
      name: 'children',
      repeatable: true,
      ignore: true,
      test: function test(type, index, tokens) {
        // è¿™é‡Œæš—å«çš„æ„æ€æ˜¯ï¼Œè¿™ä¸ªifåˆ¤æ–­å·²ç»æ»¡è¶³äº†æ˜¯å½“å‰æ˜¯endæ¡ä»¶
        if (watchAfter(tokens, index, 2).every(function (i) {
          return helper.isLineEnd(i);
        })) {
          this.content.push(tokens[index]);
          return {
            offset: 2
          };
        }

        return helper.goOn;
      }
    }]; // éœ€è¦ä¸€ä¸ªæè¿°ç¬¦å· \n{0,2}$

    return matchUsefulTokens(index, tokens, queue, handler);
  }
  /**
   * è§£æåˆ—è¡¨
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseList(index, tokens, handler) {
    if (!helper.isLineStart(tokens, index)) {
      return false;
    }

    var mtks = [];
    var liList = []; // å…ˆè·å–identï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯ - / +
    // å¦‚æœä¸æ˜¯ï¼Œå°±å‘å‰ä¸€ä¸ªå¯¹è±¡çš„children push
    // å¦‚æœæ˜¯å°±æ–°å¢ä¸€ä¸ªå¯¹è±¡

    while (true) {
      // é‡åˆ°ä¸¤ä¸ªæ¢è¡Œç»“æŸéå†
      if (tokens.slice(index, index + 2).every(function (i) {
        return helper.isLineEnd(i);
      })) {
        break;
      }

      if (matchUsefulTokens(index, tokens, [helper.getIdentMatcher(), {
        content: [],
        name: 'listType',
        nodeType: nodeType.li,
        listStyleType: '',
        test: function test(type, index, tokens) {
          if (helper.isType(type, TOKEN_TYPE.NO_ORDER_LIST, TOKEN_TYPE.ORDER_LIST)) {
            this.content.push(tokens[index]); // 'disc', // å®å¿ƒåœ†
            // 'circle', // ç©ºå¿ƒåœ†
            // 'square', // æ–¹å—

            this.listStyleType = type === TOKEN_TYPE.NO_ORDER_LIST ? 'disc' : 'decimal';
            var todoType = '';
            var isMatchTodo = watchAfter(tokens, index, 5).every(function (i, index) {
              switch (index) {
                case 0:
                  return helper.isType(i, TOKEN_TYPE.WHITE_SPACE);

                case 1:
                  return helper.isType(i, TOKEN_TYPE.URL_DESC_START);

                case 2:
                  {
                    if (helper.isType(i, TOKEN_TYPE.WHITE_SPACE)) {
                      todoType = nodeType.li_todo;
                      return true;
                    }

                    if (helper.isType(i, TOKEN_TYPE.STRING) && i.raw === 'x') {
                      todoType = nodeType.li_done;
                      return true;
                    }

                    return false;
                  }

                case 3:
                  return helper.isType(i, TOKEN_TYPE.URL_DESC_END);

                case 4:
                  return helper.isType(i, TOKEN_TYPE.WHITE_SPACE) || helper.isLineEnd(i);
              }
            });

            if (isMatchTodo) {
              var _this$content;

              (_this$content = this.content).push.apply(_this$content, _toConsumableArray(watchAfter(tokens, index, 4)));

              this.nodeType = todoType;
              return {
                offset: 5
              };
            }

            return {
              offset: 1 // TODO:å¿½ç•¥ç»“å°¾tokenï¼Œä½†å…¶å®åº”å½“æ·»åŠ åˆ°infoä¸Š

            };
          }

          return false;
        }
      }, {
        content: [],
        name: 'head',
        test: function test(type, index, tokens) {
          // æš—å«çš„æ„æ€
          var result = helper.checkIsEnd(tokens, index);

          if (result.match) {
            var _this$content2;

            // éœ€è¦è§£å†³ç«‹é©¬é‡åˆ°è¡Œå°¾çš„é—®é¢˜
            (_this$content2 = this.content).push.apply(_this$content2, _toConsumableArray(result.match));

            return {
              offset: result.match.length // TODO:å¿½ç•¥ç»“å°¾tokenï¼Œä½†å…¶å®åº”å½“æ·»åŠ åˆ°infoä¸Š

            };
          }

          return helper.goOn;
        }
      }], function (mts, info) {
        index += mts.length;
        mtks.push.apply(mtks, _toConsumableArray(mts));
        liList.push({
          ident: info.ident,
          head: info.head,
          listStyleType: info.listType_raw.listStyleType,
          nodeType: info.listType_raw.nodeType,
          children: [],
          tokens: mts
        });
      })) {
        continue;
      }

      if (liList.length === 0) {
        return;
      }

      if (matchUsefulTokens(index, tokens, [{
        content: [],
        name: 'content',
        test: function test(type, index, tokens) {
          if (helper.isLineEnd(tokens[index])) {
            // éœ€è¦è§£å†³ç«‹é©¬é‡åˆ°è¡Œå°¾çš„é—®é¢˜
            this.content.push(tokens[index]);
            return {
              offset: 1 // TODO:å¿½ç•¥ç»“å°¾tokenï¼Œä½†å…¶å®åº”å½“æ·»åŠ åˆ°infoä¸Š

            };
          }

          return helper.goOn;
        }
      }], function (mts, info) {
        index += mts.length;
        mtks.push.apply(mtks, _toConsumableArray(mts));
        liList[liList.length - 1].children.push({
          type: 'normal',
          content: info.content,
          tokens: mts
        });
      })) {
        continue;
      }

      break;
    }

    if (liList.length !== 0) {
      handler(mtks, liList);
      return true;
    }

    return false;
  }
  /**
   * è§£æè¡¨æ ¼
   * @param {number} index
   * @param {Token[]} tokens
   * @param {MatchHanlder} handler
   * @returns
   */


  function parseTable(index, tokens, handler) {
    // å¦‚æœä¸‹ä¸€è¡Œçš„å†…å®¹æ˜¯  |----|----| è¿™ç§æ ¼å¼ï¼Œåˆ™è¡¨ç¤ºæ˜¯tableè¡¨æ ¼
    if (!helper.isLineStart(tokens, index)) {
      return false;
    } // å®ç°ä¸€ä¸ªç®€å•çš„å‘å‰å‘åçœ‹çš„æ­£åˆ™


    var queue = [{
      content: [],
      children: [],
      name: 'thead',
      test: function test(type, index, tokens) {
        // æœŸæœ›å­—ç¬¦
        if (type !== TOKEN_TYPE.TABLE_SPLIT) {
          if (this.children.length === 0) {
            // å¿½ç•¥è¡Œé¦–çš„ç©ºæ ¼
            if (helper.isType(type, TOKEN_TYPE.WHITE_SPACE)) {
              return helper.goOn;
            }

            this.children.push([]);
          } // éœ€è¦æ—¶è¿ç»­çš„ - ï¼Œ --ä¹‹é—´ä¸èƒ½æœ‰ç©ºæ ¼


          this.children[this.children.length - 1].push(tokens[index]);
        } else if (type === TOKEN_TYPE.TABLE_SPLIT) {
          // ä¸‹ä¸€ä¸ªæ˜¯æœ‰æ•ˆå­—ç¬¦
          // ç¬¬ä¸€ä¸ªæ˜¯ç©ºæ ¼ ç¬¬äºŒä¸ªæ˜¯æœ‰æ•ˆå­—ç¬¦
          if (!helper.isType(tokens[index + 1], TOKEN_TYPE.WHITE_SPACE, TOKEN_TYPE.LINE_END, TOKEN_TYPE.TABLE_SPLIT) || helper.isType(tokens[index + 1], TOKEN_TYPE.WHITE_SPACE) && !helper.isType(tokens[index + 2], TOKEN_TYPE.WHITE_SPACE, TOKEN_TYPE.LINE_END, TOKEN_TYPE.TABLE_SPLIT)) {
            this.hasSplit = true;
            this.children.push([]);
          }
        } // ----|----|------


        if (helper.isLineEnd(tokens[index])) {
          if (!this.hasSplit || this.children.length === 0) {
            return false;
          }

          this.content.push(tokens[index]); // å¦‚æœå­—ç¬¦ä¸²

          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }, {
      content: [],
      name: 'split',
      children: [],
      test: function test(type, index, tokens) {
        // ä¸ä¼šå­˜åœ¨è¿ç»­çš„ç©ºæ ¼
        if (!helper.isType(type, TOKEN_TYPE.NO_ORDER_LIST, TOKEN_TYPE.WHITE_SPACE, TOKEN_TYPE.LINE_END, TOKEN_TYPE.TABLE_SPLIT)) {
          this.stop = true;
          return false;
        }

        if (type !== TOKEN_TYPE.TABLE_SPLIT) {
          if (this.children.length === 0) {
            // å¿½ç•¥è¡Œé¦–çš„ç©ºæ ¼
            if (helper.isType(type, TOKEN_TYPE.WHITE_SPACE)) {
              return helper.goOn;
            }

            this.children.push([]);
          } // éœ€è¦æ—¶è¿ç»­çš„ - ï¼Œ --ä¹‹é—´ä¸èƒ½æœ‰ç©ºæ ¼


          this.children[this.children.length - 1].push(tokens[index]);
        } else if (type === TOKEN_TYPE.TABLE_SPLIT) {
          // ç¬¬ä¸€ä¸ªæ˜¯ -
          // ç¬¬ä¸€ä¸ªæ˜¯ç©ºæ ¼ ç¬¬äºŒä¸ªæ˜¯ -
          if (helper.isType(tokens[index + 1], TOKEN_TYPE.NO_ORDER_LIST) || helper.isType(tokens[index + 1], TOKEN_TYPE.WHITE_SPACE) && helper.isType(tokens[index + 2], TOKEN_TYPE.NO_ORDER_LIST)) {
            this.hasSplit = true;
            this.children.push([]);
          }
        } // ----|----|------


        if (helper.isLineEnd(tokens[index])) {
          if (!this.hasSplit || this.children.length === 0) {
            return false;
          }

          this.content.push(tokens[index]); // å¦‚æœå­—ç¬¦ä¸²

          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }, {
      content: [],
      children: [],
      // [[[xxx], [yyyyy]], []]
      name: 'tbody',
      // äºŒçº§åµŒå¥—
      test: function test(type, index, tokens) {
        if (helper.isType(type, TOKEN_TYPE.LINE_END)) {
          this.children.push([]);
        } else {
          if (this.children.length === 0) {
            if (helper.isType(type, TOKEN_TYPE.WHITE_SPACE)) {
              return helper.goOn;
            }

            this.children.push([]);
          }

          var lastRow = this.children[this.children.length - 1]; // | xcxxx

          if (helper.isType(type, TOKEN_TYPE.TABLE_SPLIT)) {
            if (!helper.isType(tokens[index + 1], TOKEN_TYPE.WHITE_SPACE, TOKEN_TYPE.LINE_END, TOKEN_TYPE.TABLE_SPLIT) || helper.isType(tokens[index + 1], TOKEN_TYPE.WHITE_SPACE) && !helper.isType(tokens[index + 2], TOKEN_TYPE.WHITE_SPACE, TOKEN_TYPE.LINE_END, TOKEN_TYPE.TABLE_SPLIT)) {
              lastRow.push([]);
            }
          } else {
            if (lastRow.length === 0) {
              lastRow.push([]);
            }

            lastRow[lastRow.length - 1].push(tokens[index]);
          }
        }

        if (watchAfter(tokens, index, 2).every(function (i) {
          return helper.isLineEnd(i);
        })) {
          this.content.push(tokens[index]); // å¦‚æœå­—ç¬¦ä¸²

          return {
            offset: 1
          };
        }

        return helper.goOn;
      }
    }]; // éœ€è¦ä¸€ä¸ªæè¿°ç¬¦å· \n{0,2}$

    return matchUsefulTokens(index, tokens, queue, handler);
  }

  function parser() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return toAST(token(str));
  }
  /**@typedef {import("../@type").DiffResult} DiffResult */


  function insertBefore(newDom, refDom) {
    if (refDom && refDom.parentElement) {
      refDom.parentElement.insertBefore(newDom, refDom);
    }

    return newDom;
  }
  /**
   *
   * å¯¹diffç»“æœåšpatch
   * @param {DiffResult} diffResult
   */


  function patch() {
    var diffResult = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var $container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;
    diffResult.forEach(function (item) {
      var nextNode = item.nextNode;

      switch (item.type) {
        case 'del':
          {
            var $prevNodeDom = item.prevNode.$getNode(item.type);

            if (!$prevNodeDom.parentElement) {
              console.log('delete error::', item);
            }

            $prevNodeDom.parentElement.removeChild($prevNodeDom);
            break;
          }

        case 'add':
          {
            var $realContainer = nextNode.__parent && nextNode.__parent.$getNode(item.type) || $container;
            trans(nextNode, $realContainer, {
              // è‡ªå®šä¹‰æ–°èŠ‚ç‚¹çš„æ’å…¥ä½ç½®ï¼Œè€Œä¸æ˜¯æ‰€æœ‰çš„æ’åœ¨æœ«å°¾å¤„
              beforeAppend: function beforeAppend(ele) {
                var ref = $realContainer.childNodes[item.moveTo];

                if (ref) {
                  insertBefore(ele, ref);
                  return true;
                }
              }
            });
            break;
          }

        case 'replace':
          {
            var _$prevNodeDom = item.prevNode.$getNode(item.type);

            var $parent = document.createDocumentFragment();
            trans(nextNode, $parent);

            _$prevNodeDom.parentElement.replaceChild($parent, _$prevNodeDom);

            break;
          }

        case 'move':
          {
            var moveTo = item.moveTo;
            var prevNode = item.prevNode;

            var _$prevNodeDom2 = prevNode.$getNode(item.type);

            var parent = _$prevNodeDom2.parentElement; // å¦‚æœç›®æ ‡å…ƒç´ å’Œå½“å‰å…ƒç´ ç›¸åŒï¼Œåˆ™ä¸ç”¨ç§»åŠ¨

            if (parent.childNodes[moveTo] !== _$prevNodeDom2) {
              if (parent.childNodes[moveTo]) {
                insertBefore(_$prevNodeDom2, parent.childNodes[moveTo]);
              } else {
                parent.appendChild(_$prevNodeDom2);
              }
            }

            break;
          }

        case 'update':
          {
            var propsChange = item.propsChange,
                _prevNode = item.prevNode,
                _nextNode = item.nextNode;

            var _$prevNodeDom3 = _prevNode.$getNode(item.type); // ç»§æ‰¿htmlNode


            _nextNode.$getNode = _prevNode.$getNode;

            if (_prevNode.__node) {
              _nextNode.__node = _prevNode.__node;
            } // ç»§æ‰¿update


            if (_prevNode.__update) {
              _nextNode.__update = _prevNode.__update;
            }

            propsChange.forEach(function (item) {
              var key = item.key;

              switch (item.type) {
                case 'change':
                case 'add':
                  {
                    var newValue = _nextNode[key]; // å¦‚æœæœ‰è‡ªå¸¦æ›´æ–°æ–¹æ³•

                    if (_prevNode.__update) {
                      _prevNode.__update(key, _nextNode);

                      break;
                    } // æ›´æ–°æ–‡æœ¬èŠ‚ç‚¹


                    if (_$prevNodeDom3 instanceof Text) {
                      _$prevNodeDom3.data = newValue;
                      break;
                    } // æ›´æ–°å…¶ä»–å±æ€§


                    _$prevNodeDom3.setAttribute(key, newValue);

                    break;
                  }

                case 'del':
                  {
                    _$prevNodeDom3.removeAttribute(key);

                    break;
                  }
              }
            });
            break;
          }

        default:
          {
            console.error('canot handle type', item, item.type);
          }
      }
    });
  } // è·å–èŠ‚ç‚¹ä¸Šçš„æ‰€æœ‰æ–‡æœ¬ä¿¡æ¯

  /**
   * éå†èŠ‚ç‚¹è·å–Nodeå†…çš„å›¾ç‰‡ã€æ–‡æœ¬ä¿¡æ¯
   * @param  {Node} node [markdown AST]
   */


  function getParserNodeInfo(node) {
    var text = '';
    var imgs = [];

    function next(mNode) {
      if (mNode.type == 'text') {
        text += mNode.value || '';
      }

      if (mNode.type == 'img') {
        imgs.push(mNode.src);
      }

      mNode.children && mNode.children.forEach(next);
    }

    next(node);
    return {
      text: text,
      imgs: imgs
    };
  }
  /**
   * ASTè½¬HTMLNode
   * è½¬æ¢ç»“æŸåASTä¸Šéœ€è¦æœ‰HTMLNodeçš„å¼•ç”¨ï¼Œæ–¹ä¾¿ä¸‹æ¬¡patchï¼Œå¯¹HTMLNodeåšå¢åˆ æ”¹
   * ASTä¹Ÿåº”è¯¥æä¾›props updateæ–¹æ³•ï¼Œç”¨æ¥å¤„ç†propsæ›´æ–°
   */

  /**@typedef {import("../@type").ASTNode} ASTNode */
  // æ”¯æŒssr
  // æŠ½è±¡çš„æ“ä½œ ç§»åŠ¨/åˆ é™¤/update
  // ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºæ¯”å¦‚æœ‰äº›type videoï¼Œæˆ‘ä»¬æƒ³ä½¿ç”¨ä¸€ä¸ªç»„ä»¶æ¥å®ç°ï¼Œè€Œéä¸€ä¸ªhtmlæ ‡ç­¾æ¥å®ç°
  // æ‰€è°“çš„æ¸²æŸ“åˆ°å¤šç«¯


  function removeAllChildren(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  /**
   * AST è½¬ dom
   * @param {ASTNode} node
   * @param {HTMLElement} $parent
   */


  function trans(node, $parent) {
    var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var ele; // æ¥å—å­èŠ‚ç‚¹çš„å…ƒç´ 

    var realRoot; // çœŸæ­£çš„æ ¹èŠ‚ç‚¹ï¼Œå› ä¸ºå¯¹äºæŸäº›nodeï¼Œä»–çš„æ¸²æŸ“é€»è¾‘ä¸æ˜¯ä¸€ä¸ªç®€å•çš„htmlæ ‡ç­¾ï¼Œè€Œæ˜¯å¤šä¸ªæ ‡ç­¾

    var $getNode = function $getNode() {
      return ele;
    };

    switch (node.type) {
      case nodeType.audio:
      case nodeType.video:
        {
          // å¤„ç†iframe
          // æˆ‘ä»¬å…è®¸æ·»åŠ iframeï¼Œä½†æ˜¯é™åˆ¶iframeçš„å¤§å°
          if (/^<iframe(\s*.+)*><\/iframe>$/.test(node.src.trim())) {
            ele = document.createElement('div');
            ele.className = 'audio'; // https ä¸å…è®¸åŠ è½½httpçš„iframe

            ele.innerHTML = node.src.replace('http://', '//');
            var iframe = ele.querySelector('iframe');
            iframe.style.cssText += ';max-width: 100%; max-height: 60vw; overflow: hidden;';
          } else {
            ele = document.createElement(node.type);
            ele.src = node.src;
            ele.alt = node.alt;
            ele.controls = 'true';
          }

          break;
        }

      case nodeType.img:
        {
          var result = node.src.match(/\.(\d+)x(\d+)\./);

          if (result) {
            var _result$slice = result.slice(1, 3),
                _result$slice2 = _slicedToArray(_result$slice, 2),
                width = _result$slice2[0],
                height = _result$slice2[1]; // å›¾ç‰‡å®½é«˜å ä½


            var src = node.src;
            ele = document.createElement('div');
            ele.style.cssText = ";position: relative; max-width: ".concat(width, "px; overflow: hidden; background: rgb(219, 221, 215);");
            ele.innerHTML = "<div style=\"padding-top: ".concat(height / width * 100, "%;\">\n                    <img ").concat( // eslint-disable-next-line no-undef
            LY.lazyLoad.caches.includes(src) ? "src=\"".concat(src, "\" data-img-cache=\"true\"") : '', "\n                        class=\"lazy-load-img img-loading\"\n                        data-lazy-img=\"").concat(node.src, "\"\n                        data-src=\"").concat(node.src, "\"\n                        referrerpolicy=\"no-referrer\"\n                        style=\"position: absolute; width: 100%; height: 100%; top: 0;\" />\n                </div>");
            break;
          } else {
            ele = document.createElement(node.type);
            ele.src = node.src;
            ele.alt = node.alt;
            ele.referrerPolicy = 'no-referrer';
            break;
          }
        }

      case nodeType.url:
        {
          ele = document.createElement(node.type);
          ele.href = node.href;
          ele.target = '_blank';
          break;
        }

      case nodeType.text:
        {
          // const text = node.value;
          // ele = document.createTextNode(text);
          ele = document.createElement('span');
          ele.setAttribute('md-type', 'text-node');

          node.__update = function (key, newNode) {
            removeAllChildren(ele); // å¯¹çº¯æ–‡æœ¬èŠ‚ç‚¹åšé“¾æ¥æå–ï¼Œæå‡ç”¨æˆ·ä½“éªŒ

            newNode[key].split(/([A-z]+:\/{2}\S+)/g).forEach(function (i, index) {
              if (index % 2 === 1) {
                var a = document.createElement('a');
                a.href = i;
                a.textContent = i;
                a.target = '_blank';
                ele.appendChild(a);
              } else {
                ele.appendChild(document.createTextNode(i));
              }
            });
          };

          node.__update('value', node);

          break;
        }

      case nodeType.br:
        {
          ele = document.createElement(node.type);
          break;
        }

      case nodeType.linethrough:
        {
          ele = document.createElement('span');
          ele.style.cssText += '; text-decoration: line-through;';
          break;
        }

      case nodeType.code:
        {
          ele = document.createElement('pre');
          var code = document.createElement('code'); // éœ€è¦åœ¨nodeä¸Šæ·»åŠ __updateæ–¹æ³•ï¼Œæ–¹ä¾¿æ›´æ–°å±æ€§

          node.__update = function (key, newNode) {
            switch (key) {
              case 'language':
                {
                  code.className = ['highlight', newNode[key] || ''].join(' ');
                  break;
                }

              case 'code':
                {
                  code.textContent = newNode[key]; // ä¸èƒ½ä½¿ç”¨innerHTML

                  break;
                }
            }
          };

          node.__update('language', node);

          node.__update('code', node);

          ele.appendChild(code);
          break;
        }

      case nodeType.inlineCode:
        {
          ele = document.createElement('code');
          ele.className = 'inlineCode';
          break;
        }

      case nodeType.head:
        {
          ele = document.createElement("h".concat(node.level)); // æ·»åŠ ä¸€ä¸ª
          // const a = document.createElement('a')
          // const id = getText(node)
          // a.href = `#${id}`
          // a.id = id
          // ele.appendChild(a)

          break;
        }

      case nodeType.ul:
        {
          ele = document.createElement(node.type);

          node.__update = function (key, nodeNode) {
            ele.style.cssText += ";list-style-type:".concat(nodeNode[key], ";");
          };

          node.__update('listStyleType', node);

          break;
        }
      // éœ€è¦å®Œæˆä¸€ä¸ªäº‹æƒ…ï¼Œå°±æ˜¯æ·»åŠ å’Œdomæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥åŒ…ä¸¤å±‚ï¼ŒåŒ…å‡ å±‚çš„ç»“æœæ˜¯ï¼Œåˆ é™¤å’Œæ›¿æ¢çš„æ—¶å€™éœ€è¦ç‰¹æ®Šå¤„ç†ä¸€ä¸‹
      // ä»¥é¿å…domæ²¡æœ‰åˆ é™¤æˆ–è€…æ›¿æ¢å¹²å‡€
      // add / remove / replace / move

      /**
       * node.getRoot = () => [è¿”å›çœŸå®çš„æ ¹èŠ‚ç‚¹]ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªæ•°ç»„
       */

      case nodeType.li_done:
      case nodeType.li_todo:
        {
          realRoot = document.createElement('li');
          var tag = document.createElement('span');
          tag.className = 'list-todo-tag';
          tag.textContent = node.type === nodeType.li_done ? 'âœ…' : 'ğŸš§';
          realRoot.appendChild(tag);
          ele = document.createElement('span');
          realRoot.appendChild(ele);
          realRoot.style.cssText += ";list-style: none;";

          $getNode = function $getNode(type) {
            return type === 'add' ? ele : realRoot;
          };

          break;
        }

      case nodeType.h3:
      case nodeType.h2:
      case nodeType.h1:
        {
          ele = document.createElement(node.type); // ä¸ºæ ‡é¢˜æ·»åŠ idï¼Œä»¥æ”¯æŒé”šç‚¹

          node.__update = function (key, newNode) {
            if (key === 'id') {
              ele.id = getParserNodeInfo(newNode).text.trim();
            }
          };

          node.__update('id', node);

          break;
        }

      default:
        {
          ele = document.createElement(node.type);
          node.indent && (ele.style.cssText += ';padding-left: 2em;'); // tableè¡¨æ ¼éœ€è¦è®¾ç½®è¾¹æ¡†

          if (node.type == nodeType.table) {
            ele.setAttribute('border', '0');
          }
        }
    }

    realRoot = realRoot || ele;
    node.$getNode = $getNode;
    node.tag && ele.setAttribute('tag', node.tag);
    node.children && node.children.forEach(function (child) {
      return trans(child, ele);
    });

    if (!(option.beforeAppend && option.beforeAppend(realRoot))) {
      $parent.appendChild(realRoot);
    }

    return ele;
  }

  var cache = {}; // è·å–è§£æç»“æœ

  function getParseResult() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var parseResult = cache[str];

    if (!parseResult) {
      var root = parser(str);
      parseResult = _objectSpread({
        root: root
      }, getParserNodeInfo(root));
      cache[str] = parseResult;
    }

    return parseResult;
  }

  var loadedAsset = {}; // åŠ è½½é™æ€èµ„æº

  function loadAsset(url) {
    return new Promise(function (res) {
      if (loadedAsset[url]) {
        return res();
      }

      var onload = function onload() {
        loadedAsset[url] = true;
        res();
      };

      if (url.endsWith('.js')) {
        var s = document.createElement('script');
        s.onload = onload;
        s.src = url;
        document.head.appendChild(s);
      } else if (url.endsWith('.css')) {
        var _s2 = document.createElement('link');

        _s2.onload = onload;
        _s2.type = 'text/css';
        _s2.rel = 'stylesheet';
        _s2.charset = 'utf-8';
        _s2.href = url;
        document.head.appendChild(_s2);
      }
    });
  }
  /**
   * [codeHighlight ä»£ç é«˜äº®]
   * @param  {HTMLElement}      dom [ä»£ç é«˜äº®]
   */


  function codeHighlight(dom, config) {
    Promise.all(config.asset.map(loadAsset)).then(function () {
      if (!window.hljs || !dom) return;
      window.hljs.configure({
        // useBR: true, // æ˜¯å¦ä½¿ç”¨br
        tabReplace: 4
      });

      _toConsumableArray(dom.querySelectorAll('code.highlight')).forEach(function (code) {
        window.hljs.highlightBlock(code);
      });
    });
  }

  function getConfig(initConfig) {
    return _objectSpread({
      asset: []
    }, initConfig);
  }

  var Markdown = /*#__PURE__*/function () {
    function Markdown(dom, config, str) {
      _classCallCheck(this, Markdown);

      this.dom = dom;
      this.config = config;
      this.prevRoot = null;

      if (str) {
        this.update(str);
      }
    }

    _createClass(Markdown, [{
      key: "update",
      value: function update(str) {
        this.dom.classList.add('markdown');
        var result = getParseResult(str);
        var diffResult = diffNode(this.prevRoot, result.root);
        this.prevRoot = result.root;
        patch(diffResult, this.dom);
        var config = getConfig(this.config);
        codeHighlight(this.dom, config);
      }
    }]);

    return Markdown;
  }();

  function markdown($dom, str, config) {
    $dom.innerHTML = '';
    $dom.classList.add('markdown');
    var result = getParseResult(str);
    trans(result.root, $dom);
    config = getConfig(config);
    codeHighlight($dom, config);
  }

  function markdownInfo(str) {
    // eslint-disable-next-line no-unused-vars
    var _getParseResult = getParseResult(str),
        root = _getParseResult.root,
        info = _objectWithoutProperties(_getParseResult, ["root"]);

    return info;
  }

  exports.Markdown = Markdown;
  exports.codeHighlight = codeHighlight;
  exports.getParseResult = getParseResult;
  exports.markdown = markdown;
  exports.markdownInfo = markdownInfo;
  exports.parser = parser;
  exports.trans = trans;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  return exports;
}({});